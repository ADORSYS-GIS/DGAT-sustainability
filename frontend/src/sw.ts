/// <reference lib="webworker" />

import { precacheAndRoute, cleanupOutdatedCaches } from "workbox-precaching";
import { registerRoute, NavigationRoute } from "workbox-routing";
import {
  NetworkFirst,
  CacheFirst,
  StaleWhileRevalidate,
  NetworkOnly,
} from "workbox-strategies";
import { ExpirationPlugin } from "workbox-expiration";
import { CacheableResponsePlugin } from "workbox-cacheable-response";
import { BackgroundSyncPlugin } from "workbox-background-sync";

declare const self: ServiceWorkerGlobalScope;

// Define cache names
const CACHE_NAME = "dgat-sustainability-v1";
const urlsToCache = ["/", "/index.html", "/manifest.json"];

// Clean up outdated caches
cleanupOutdatedCaches();

// Precache all of the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Skip waiting and claim clients immediately
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll(urlsToCache);
    }),
  );
  self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        }),
      );
    }),
  );
  event.waitUntil(self.clients.claim());
});

// Navigation fallback for SPA
registerRoute(
  new NavigationRoute(
    new NetworkFirst({
      cacheName: "navigation-cache",
      networkTimeoutSeconds: 3,
      plugins: [
        new CacheableResponsePlugin({
          statuses: [0, 200],
        }),
        new ExpirationPlugin({
          maxEntries: 50,
          maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
        }),
      ],
    }),
    {
      // Only apply to navigation requests that don't match these patterns
      denylist: [
        /^\/api/,
        /^\/health/,
        /\.(?:json|xml|csv)$/,
        /\/_next\/static\//,
        /\/static\//,
      ],
    },
  ),
);

// Cache API requests with NetworkFirst strategy
registerRoute(
  ({ url }) => url.pathname.startsWith("/api/"),
  new NetworkFirst({
    cacheName: "api-cache",
    networkTimeoutSeconds: 10,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200, 201, 204, 404, 500],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
    ],
  }),
);

// Cache health check endpoints
registerRoute(
  ({ url }) => url.pathname.startsWith("/health"),
  new NetworkFirst({
    cacheName: "health-cache",
    networkTimeoutSeconds: 5,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 5, // 5 minutes
      }),
    ],
  }),
);

// Cache static assets (JS, CSS, images) with CacheFirst
registerRoute(
  ({ request }) =>
    request.destination === "script" ||
    request.destination === "style" ||
    request.destination === "image",
  new CacheFirst({
    cacheName: "static-assets-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  }),
);

// Cache fonts with CacheFirst
registerRoute(
  ({ request }) => request.destination === "font",
  new CacheFirst({
    cacheName: "fonts-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  }),
);

// Cache Google Fonts
registerRoute(
  ({ url }) =>
    url.origin === "https://fonts.googleapis.com" ||
    url.origin === "https://fonts.gstatic.com",
  new CacheFirst({
    cacheName: "google-fonts-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  }),
);

// Background sync for offline API requests
const bgSyncPlugin = new BackgroundSyncPlugin("api-queue", {
  maxRetentionTime: 24 * 60, // Retry for up to 24 hours
});

// Handle POST/PUT/DELETE requests with background sync
registerRoute(
  ({ url, request }) =>
    url.pathname.startsWith("/api/") &&
    ["POST", "PUT", "DELETE", "PATCH"].includes(request.method),
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  }),
  "POST",
);

// Fallback for offline navigation
self.addEventListener("fetch", (event) => {
  if (event.request.mode === "navigate") {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match("/index.html");
      }),
    );
  }
});

// Handle offline fallback for API requests
self.addEventListener("fetch", (event) => {
  const { request } = event;

  // Only handle API requests
  if (request.url.includes("/api/")) {
    event.respondWith(
      fetch(request)
        .then((response) => {
          // Only cache GET requests (PUT, POST, DELETE are not cacheable)
          if (
            request.method === "GET" &&
            (response.status === 200 || response.status === 201)
          ) {
            const responseClone = response.clone();
            caches.open("api-cache").then((cache) => {
              cache.put(request, responseClone);
            });
          }

          return response;
        })
        .catch(() => {
          // For non-GET requests, don't try to return cached responses
          if (request.method !== "GET") {
            return new Response("Offline mode: Operation not available", {
              status: 503,
              headers: { "Content-Type": "application/json" },
            });
          }

          // Return cached response if available (only for GET requests)
          return caches.match(request).then((cachedResponse) => {
            if (cachedResponse) {
              return cachedResponse;
            }

            // Return offline fallback for specific endpoints
            if (request.url.includes("/api/assessments")) {
              return new Response(
                JSON.stringify({
                  message: "Offline mode: Data not available",
                  offline: true,
                }),
                {
                  status: 503,
                  headers: { "Content-Type": "application/json" },
                },
              );
            }

            return new Response("Offline mode", { status: 503 });
          });
        }),
    );
  }
});

// Log service worker events for debugging
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }

  if (event.data && event.data.type === "GET_VERSION") {
    event.ports[0].postMessage({ version: "1.0.0" });
  }
});
